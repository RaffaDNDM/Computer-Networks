\chapter{Gnu Project Debugger (GDB)}
To use gdb you need to do the following 2 steps:
\begin{enumerate}
\item{Compile the program with \textbf{-g} option, as follow:
\begin{lstlisting}[linewidth=120pt, basicstyle=\footnotesize\sffamily,]
gcc -g -o test test.c
\end{lstlisting}
}
\item{Call gdb on the program you want to debug, as follow:
\begin{lstlisting}[linewidth=40pt, basicstyle=\footnotesize\sffamily,]
gdb test
\end{lstlisting}
}
\item{Call \textit{run} inside gdb, to run the program. You can add also command line arguments just writing them after run in the same line.
}
\item{Call \textit{quit} inside GDB to terminate the session}
\end{enumerate}
\section{GDB commands}
\subsection{Breakpoints}
\begin{table}[h]
\footnotesize\centering
\begin{tabular}{|l|l|}
\hline
{\textbf{break name\_function}} & {Set breakpoint on function called \textit{name\_function}}\\
{\textbf{break example.c:name\_function}} & {Set breakpoint on function called \textit{name\_function} in file example.c}\\
\hline
{\textbf{break XX}} & {Set breakpoint at line numbered XX}\\
{\textbf{break} or \textbf{b}} & {Set breakpoint at line in which the program has already failed}\\
{\textbf{break example.c:XX}} & {Set breakpoint at line numbered XX in file example.c}\\
\hline
{\textbf{clear XX}} & {Remove breakpoint at line numbered XX}\\
\hline
{\textbf{watch name\_variable}} & {Program will stop whenever the variable \textit{name\_variable} changes}\\
\hline
{\textbf{step}} & {Step into a function call}\\
\hline
{\textbf{next} or \textbf{n}} & {Step over a function call}\\
\hline
{\textbf{bt}} & {Print backtrace of the entire stack}\\
\hline
{\textbf{up [count]}} & {Select the previous (outer) stack frame or one of the frames preceding it (count frames up).}\\
\hline
{\textbf{ENTER}} & {Repeat the last command}\\
\hline
{\textbf{continue} or \textbf{c}} & {Continue until the next breakpoint or watchpoint is reached}\\
\hline
\end{tabular}
\end{table}
\subsection{Conditional breakpoints}
Breakpoint with a condition statement. This is usefull, because you could insert condition also directly in the code but doing this you could add bugs that weren't before. A conditional breakpoint is made by adding if condition after the break statement in GDB, as follows:
\begin{lstlisting}[linewidth=170pt, basicstyle=\footnotesize\sffamily,]
break example.c:60 if (x > 255)
\end{lstlisting}
There are also conditional watchpoints made by typing sentences like the folllowing:
\begin{lstlisting}[linewidth=60pt, basicstyle=\footnotesize\sffamily,]
watch x > 10
\end{lstlisting}
In this case the watchpoint will be set on x and the program stops when x reaches reaches the value \textit{0x11}. It can be usefull on multithreading.

\subsection{Examine memory}
To examine the memory you need to call the command \textit{x} in one of the following ways:
\begin{lstlisting}[linewidth=60pt, basicstyle=\footnotesize\sffamily,]
x/nfu addr
x addr
x
\end{lstlisting}
where n, f, and u are all optional parameters that specify how much memory to display and how to format it; addr is an expression giving the address where you want to start displaying memory. If you use defaults for nfu, you need not type the slash ‘/’. Several commands set convenient defaults for addr.
\begin{table}[h]
\footnotesize\centering
\begin{tabular}{|l|l|}
\hline
{\textbf{n}} & {The repeat count is a decimal integer; the default is 1.}\\
{} & {It specifies how much memory (counting by units u) to display.}\\
{} & {If a negative number is specified, memory is examined backward from addr.}\\
\hline
{\textbf{f}} & {The display format is one of the formats used by print}\\
{} & {(‘x’, ‘d’, ‘u’, ‘o’, ‘t’, ‘a’, ‘c’, ‘f’, ‘s’) and in addition ‘i’}\\
{} & {(for machine instructions). The default is ‘x’ (hexadecimal) initially.}\\
{} & {The default changes each time you use either x or print}\\
\hline
{\textbf{u}} & {Unit size (default = \textit{w} except for \textit{s} format that is \textit{b})}\\
{} & {\textbf{b} = bytes                \textbf{w} = words (4B)}\\
{} & {\textbf{h} = halfwords (2B)       \textbf{g} = giant words (8B)}\\
\hline
\end{tabular}
\end{table}
There are other commands used to examine and to set variable values to something. These are:
\begin{table}[h]
\footnotesize\centering
\begin{tabular}{|l|l|}
\hline
{\textbf{print name\_variable}} & {Print the value of variable called \textit{name\_variable}}\\
{\textbf{p name\_variable}} & {}\\
\hline
{\textbf{list}}  & {Show all the code in the file}\\
\hline
{\textbf{set var} name\_variable=value} & {Set the value of the variable \textit{name\_variable} equal to \textit{value}}\\
\hline
\end{tabular}
\end{table}
\subsection{Automate tasks in gdb}
You can insert all the commands that you want to launch on gdb in a file \textit{init.gdb} and then pass it to the program thanks to the option \textit{-x}, as follows:
\begin{lstlisting}[linewidth=110pt, basicstyle=\footnotesize\sffamily,]
gdb test -x init.gdb
\end{lstlisting}

\subsection{Debugging with fork() and exec()}
\begin{table}[h]
\footnotesize\centering
\begin{tabular}{|l|l|}
\hline
{\textbf{set follow-fork-mode child}} & {Specify that GDB needs to follow the child process after the fork() call in the program.}\\
\hline
{\textbf{set follow-exec-mode new}} & {Specify that GDB needs to follow the new program called by exec.}\\
\hline
\end{tabular}
\end{table}
\vspace{5cm}
\subsection{Debugging with multiple threads}
\begin{table}[h]
\footnotesize\centering
\begin{tabular}{|l|l|}
\hline
{\textbf{info threads}} & {Show the current threads in the program.}\\
\hline
{\textbf{thread num}} & {Switch to the execution made by thread with number \textit{num}.}\\
{\textbf{thread apply all} \textit{command}} & {Command is applied on all the threads.}\\
\hline
\end{tabular}
\end{table}