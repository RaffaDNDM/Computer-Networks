# Data Link Layer
  <details> <summary> <b><i>arp.c</b></i> </summary>
  Implementation of ARP protocol for Address Resolution (ARP request + ARP reply).
  </details>
  <details> <summary> <b><i>inverse_ping.c</b></i> </summary>
  Program that analyses an ECHO request, sent by a remote node, and replies to it with an ECHO reply. The program follows these steps:
  <ol>
  <li>It waits for an ECHO Request</li>
  <li>It receives the ECHO Request</li>
  <li>It sends the ECHO reply, following ICMP rules explained in <a href="https://tools.ietf.org/html/rfc792">RFC 792</a></li>
  <li>It ends the execution</li>
  </ol>
  The program execute the testing phase, by calling the command ping on a remote machine called <i>"lab"</i>.
  </details>
  <details> <summary> <b><i>ping.c</b></i> </summary>
  Implementation of PING application, using ICMP ECHO request and ECHO reply.
  </details>
  <details> <summary> <b><i>record_route.c</b></i> </summary>
  It constructs the IP datagram by adding the optional "Record Route" field to the IP header (<a href="https://tools.ietf.org/html/rfc791#section-3.1">Section 3.1 RFC 791</a>). This field reserves a free area (called route data) inside the extended IP header, intended to contain the list of IP addresses of the nodes crossed by the packet. <br>Each node crossed, in fact, in the presence of the "Record Route" option, should append its IP address in the area route data to the IP addresses list already saved by the previous nodes. The fields length and pointer allow you to manage the memory area during the packet trip.
  </details>
  <details><summary> <b><i>split_ping.c</b></i> </summary>
  The program works as a ping but splitting the ECHO request in 2 different IP packets:
  <ol>
  <li>With payload size of 16 bytes</li>
  <li>With payload of needed size</li>
  </ol>
  To program it, I used the fragmentation of IP datagrams (<a href="https://tools.ietf.org/html/rfc791#section-3.1">Section 3.1 of RFC 791</a>). 
  </details>
  <details> <summary> <b><i>statistics.c</b></i> </summary>
  The program receives 1000 packets from the network, counts them and, after receiving all the frames, writes the following statistics:
  <ul>
  <li>% frames containing IP packets</li>
  <li>% frames containing ARP packets</li>
  <li>% frames containing neither IP nor ARP</li>
  </ul>
  and looking to all the IP datagrams received, it prints:
  <ul>
  <li>% packets containing TCP segments</li>
  <li>% packets containing UDP segments</li>
  <li>% packets containing ICMP packets</li>
  <li>% packets containing other payload</li>
  </ul>
  </details>
  <details> <summary> <b><i>tcp.c</b></i> </summary>
  The program sends a request for TCP connection to a web service on an IP packet addressed to <i>147.162..X</i>, waits for and processes the reply.<br>
  The request follows these requirements (<a href="https://tools.ietf.org/html/rfc793">RFC 793</a>):
  <ul>
    <li>The SYN flag is set to 1 to indicate the connection request.</li> 
    <li>The destination port is the standard web service.</li>
    <li>The source port is an arbitrary number that is always different for each connection request.</li>
    <li>The Sequence field contains an always different arbitrary number for each connection request.</li> 
    <li>The Acknowledgment field is irrelevant.</li>
    <li>The urgent pointer field is set to 0.</li>
    <li>The advertised window0xFFFF.</li>
    <li>The payload field is empty.</li>
    <li>No options/padding.</li> 
  </ul>
  To verify that all was correct, the program automatically checks that a TCP segment is received in response with the following requirements:
  <ul>
    <li>The source port corresponds to the standard port of the web service</li>
    <li>The destination port corresponds to the source port indicated in the request</li> 
    <li>The segment has the <i>Acknowledgment field = Sequence number of request + 1</i></li>
    <li>The segment has SYN and ACK flags set to <i>1</i>.</li>
  </ul>
  </details>
  <details> <summary> <b><i>time_exceeded.c</b></i> </summary>
  The program builds an IP datagram with a "time to live" small enough to prevent the IP datagram from reaching its destination.
  Then it intercepts the ICMP "Time Exceeded" message (<a href="https://tools.ietf.org/html/rfc792">RFC 792</a>) from the intermediate node that discarded the packet and prints the IP address that originated this message on the screen. 
  </details>
  <details> <summary> <b><i>traceroute.c</b></i> </summary>
  Implementation of PING application, using ICMP ECHO request and ECHO reply.
  </details>
  <details> <summary> <b><i>unreachable_dest.c</b></i> </summary>
  The program is able to recognize a <i>ICMP ECHO REPLY message</i> and also an <i>ICMP Unreachable Destination packet</i> (<a href="https://tools.ietf.org/html/rfc792">RFC 792</a>).<br>The <i>ICMP Unreachable Destination packet</i> is generated by a router on the network when it detects that the IP datagram, that it is forwarding, is for an IP address that can never be reached.<br>In this case the router: 
  <ol>
  <li>deletes the IP datagram (i.e. do not forward it to any other router).</li>
  <li>creates an <i>ICMP Unreachable Destination packet</i>.</li>
  <li>sends the ICMP message to the node that generated the IP datagram to warn it that the packet has been deleted.</li>
  </ol>
To test the code, the program sends an "echo request" to a non-existent IP address (e.g. <i>10.20.30.40</i>) to get an <i>ICMP Destination Unreachable message</i> in response. Then the program prints the IP address of the network that generated the <i>ICMP Destination Unreachable message</i>.
  </details>
  <details> <summary> <b><i>utility.c</b></i> </summary>
  Some utility functions, like checksum computation.
  </details>
